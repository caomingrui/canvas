<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
  <div id="root"></div>
  <canvas id="m-canvas" width='700' height='1000'></canvas>
</body>
<script>
    const canvas = document.getElementById("m-canvas");
    const rect = canvas.getBoundingClientRect();
    const ctx = canvas.getContext('2d')
    let lineStatus = false;
    let selectAreaIndex = -1, selectPointIndex = -1, areas = [], copyAreas = [];
    let downx, downy, isMouseDown = false, pointMouseMoveState = false;

    canvas.addEventListener('mousedown', (event) => {
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        let area;
        downx = x;
        downy = y;

        // 闭合后 选取areas移动
        if (!lineStatus) {
            cleanCanvas({ ctx, canvas });
            const index = isInConstituency(ctx, areas, x, y);
            if (index != -1) {
                isMouseDown = true;
                selectAreaIndex = index;
                copyAreas = areas;

                const pointIndex = clickPointIndex(x, y, areas[index]);
                if (pointIndex != -1) {
                    selectPointIndex = pointIndex;
                    pointMouseMoveState = true;
                }
                return;
            };
        }

        // 闭合新建 area 内容
        if (!lineStatus) {
            area = new Area();
            areas.push(area);
            lineStatus = true;
        }
        else {
            area = areas.slice().pop();
        }

        // 选中是否为路径上的节点
        const index = clickPointIndex(x, y, area);
        area.add({ x, y, w: 3, h: 3 });
        if (index == -1) {
            isMouseDown = true;
            drawAll(ctx, areas);
        }
        else {
            isMouseDown = false;
            lineStatus = false;
        }
    })



    canvas.addEventListener('mousemove', (event) => {
        if (!isMouseDown) return;
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const disx = x - downx;
        const disy = y - downy;
        copyAreas = JSON.parse(JSON.stringify(areas))
        cleanCanvas({ ctx, canvas });

        if (pointMouseMoveState) {
            const { points } = copyAreas[selectAreaIndex];
            const oldPointsItem = copyAreas[selectAreaIndex].points[selectPointIndex]
            points[selectPointIndex].x = oldPointsItem.x + disx;
            points[selectPointIndex].y = oldPointsItem.y + disy;

            drawAll(ctx, copyAreas);
        }
        // 拖动
        else if (!lineStatus) {
            const { points } = copyAreas[selectAreaIndex];
            points.forEach((p, ind) => {
                const oldPointsItem = copyAreas[selectAreaIndex].points[ind]
                p.x = oldPointsItem.x + disx;
                p.y = oldPointsItem.y + disy;
            })
            drawAll(ctx, copyAreas);
        }
        // 绘制路径
        else {
            drawAll(ctx, areas.map((res, ind) => {
                if (ind === areas.length - 1) {
                    return { ...res, points: res.points.concat({x,y,w: 3, h: 3}) }
                }
                return res;
            }));
        }
    })

    canvas.addEventListener('mouseup', (event) => {
        if (!isMouseDown) return;

        if (!lineStatus) {
            areas = copyAreas;
            isMouseDown = false;
            lineStatus = false;
            pointMouseMoveState = false;
            selectAreaIndex = -1;
            selectPointIndex = -1;
            return;
        }
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const points = (areas.length? areas[areas.length - 1]: areas).points;
        points.push({ x, y, w: 3, h: 3 })
        cleanCanvas({ ctx, canvas });
        drawAll(ctx, areas);
    })


    document.addEventListener('keyup', (event) => {
        if (event.ctrlKey && event.code === "KeyZ") {
            const area = areas.pop();
            area.points.pop();
            area.points.length && areas.push(area)
            cleanCanvas({ ctx, canvas });
            drawAll(ctx, areas);
        }

        if (event.code === "Backspace") {
            areas.splice(selectAreaIndex, 1);
            isMouseDown = false
            cleanCanvas({ ctx, canvas });
            drawAll(ctx, areas);
        }
    });



    function cleanCanvas ({ ctx, canvas }) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }


    function drawAll (ctx, areas, movePoint) {
        areas.forEach(item => {
            drawPoint(ctx, item);
            ctx.beginPath();
            drawLine(ctx, item, movePoint);
            ctx.closePath();
            ctx.fillStyle = "rgba(107, 250, 255, .4)";
            ctx.fill();
        });
    }


    function drawPoint (ctx, { points, add }) {
        if (!points.length) return;
        ctx.save();
        points.forEach(({ x, y, w, h }) => {
            ctx.beginPath();
            // ctx.fillRect(x, y, w, h);
            ctx.arc(x, y, 10, 0, Math.PI*2);
            ctx.closePath();
            ctx.strokeStyle = "#3e25cc";
            ctx.fill();
        });
        ctx.restore();
    }

    function drawLine (ctx, { points, add }, movePoint = null) {
        if (!points.length) return;
        points.forEach(({ x, y, w, h }, index) => {
            if (index === 0) {
                ctx.moveTo(x, y);
            }
            else {
                ctx.lineTo(x, y);
            }
        });
        if (movePoint) {
            ctx.lineTo(movePoint.x, movePoint.y);
        }
        ctx.lineWidth = 3
        const num = Math.random() * 5
        ctx.strokeStyle = 'red';
        ctx.setLineDash([num%2 ? 3: 5, 10]);
        ctx.stroke();
    }


    function Area () {
        this.points = [];
        this.add = (point) => {
            this.points.push(point);
            return this.points;
        }
    }


    function clickPointIndex (x, y, area) {
        const { points } = area;

        for(let i = 0; i < points.length; i++) {
            const p = points[i];
            //使用勾股定理计算这个点与圆心之间的距离
            const distanceFromCenter = Math.sqrt(Math.pow(p.x - x, 2) + Math.pow(p.y - y, 2));
            if (distanceFromCenter <= 20) {
                return i;
            }
        }
        return -1;
    }

    // 遍历画出所有内容， 画一个判断一个
    function isInConstituency (ctx, areas, x, y) {
        let index = -1;
        areas.forEach((item, ind) => {
            drawPoint(ctx, item);
            ctx.beginPath();
            drawLine(ctx, item);
            ctx.closePath();

            const isInPath = ctx.isPointInPath(x, y);
            if (isInPath) {
                index = ind;
            }

            ctx.fillStyle = "rgba(107, 250, 255, .4)";
            ctx.fill();
        });
        return index;
    }
</script>
</html>
